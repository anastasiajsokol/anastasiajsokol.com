<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="icon" href="//style.anastasiajsokol.com/favicon.svg">
    <title>Merge Sort</title>

    <link rel="stylesheet" href="//style.anastasiajsokol.com/style.css">
</head>
<body>
    <header>
        <h1 id="title">Merge Sort</h1>

        <hr/>

        <nav>
            <ol>
                <li><a href="/">Ana</a></li>
                <li><a href="/edu">Edu</a></li>
                <li><a href="/edu/sorting">Sorting</a></li>
                <li><span aria-current="page">Merge Sort</span></li>
            </ol>
        </nav>
    </header>

    <section>
        <h2>Basic Algorithm Overview</h2>

        <p>
            From the highest level, merge sort is a sorting algorithm that splits the input up into ever smaller chunks, then recombines (merges) each chunk in an ordered way. What exactly that entails is explored below of course, but it follows that merge sort is an inherently recursive algorithm. While it is possible to write a non-recursive function that does merge sort in an iterative fashion, the core recursive conceptualization remains.
        </p>

        <p>
            The usual implementation can be considered in four sections
        </p>

        <ol>
            <li>Recursive Base Case</li>
            <li>Partitioning</li>
            <li>Recursive Step</li>
            <li>Merging</li>
        </ol>

        <p>
            The base case for merge sort is the trivially sorted list. <i>What
                exactly entails a trivially sorted list is left here to the
                reader so that this document remains useful as a teaching tool.
                However, consider what it means for a list to be sorted, and at
                what size or sizes it would be impossible for a list not to be
                sorted.</i>
        </p>
        
        <p>
            Partitioning can be done in a few different ways, and may even mean
            a few different things, as explored in the next three sections.
            However it is important to note that what elements end up in which
            partition is largely irrelevant. This is different from 
            <a class="inactive" href="../quick-sort">quick sort</a>,
            for example, where partitioning is a core component of the sorting
            itself.
        </p>
        
        <p>
            The recursive step consists of sorting each partition. Thankfully we
            have a function that can sort each partition already! It is the
            merge sort function that we are writing right now. How each
            partition is stored may effect how this further splitting is
            implemented, however suffice to say it should not be particularly
            complicated. <i>Note that if you still feel a bit shaky about
            recursion &mdash; after all it can feel strange to define a function
            in terms of itself &mdash; that is alright! But try to convince
            yourself that the function already works for at least some inputs
            (see the base case) and that we do at least eventually reach the
            base case (consider repeated partitioning).</i>
        </p>
        
        <p>
            The final stage is the namesake of the whole algorithm. The basic
            concept is to find the smallest or largest element and which
            partition it belongs to, place that element at the beginning or end
            respectively of the output array, and then remove that element from
            the partition it was in. What makes this algorithm different from
            <a class="inactive" href="../selection-sort">selection sort</a>
            &mdash; finding the minimum or maximum element and swap it into the
            correct place &mdash; is that we are merging <i>sorted</i>
            partitions. The minimum or maximum of each partition will always be
            at the beginning or end respectively of each partition.
        </p>

        <h2>Binary Merge Sort</h2>

        <p>...</p>

        <h2>Extended Merge Sort</h2>

        <p>...</p>

        <h2>Partitioning Algorithms</h2>

        <p>...</p>

        <h2>Merging Algorithms</h2>

        <p>...</p>

        <h2>Merge In Place</h2>

        <p>Coming Soon</p>

        <h2>Analysis</h2>

        <p>[redacted semi-permanently ]</p>
    </section>
</body>
</html>